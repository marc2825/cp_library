{
	"BFS": {
		"prefix": "BFS",
		"body": [
			"// Returns the distance of all points on the graph from the starting point", 
            "vector<int> BFS(const vector<vector<int> > &G, int start) {",
            "    vector<int> dist(G.size(), -1);",
            "    dist[start] = 0;",
            "    queue<int> q;",
            "    q.push(start);",
            "",
            "    while(!q.empty()) {",
            "        int now = q.front();",
            "        q.pop();",
            "",
            "        for(auto &nxt : G[now]) {",
            "            if(dist[nxt] == -1) {",
            "                dist[nxt] = dist[now] + 1;",
            "                q.push(nxt);",
            "            }",
            "        }",
            "    }",
            "",
            "    return dist;",
            "}",
		],
		"description": "Breadth First Search (basic form using lamda function)"
	},

    "Eratosthenes": {
        "prefix": "Eratosthenes",
        "body": [
            "vector<bool> Eratosthenes(int N) {",
            "    vector<bool> isprime(N+1, true);",
            "",
            "    isprime[0] = false;",
            "    isprime[1] = false;",
            "",
            "    for (long long p = 2; p <= N; ++p) {",
            "        if (!isprime[p]) continue;",
            "",
            "        if(p * p > N) break;",
            "",
            "        for (long long q = p * p; q <= N; q += p) {",
            "            isprime[q] = false;",
            "        }",
            "    }",
            "",
            "    return isprime;",
            "}",
        ],
        "description": "Sieve of Eratosthenes (return an isprime table less than N)"
    },

    "Divisors": {
        "prefix": "Divisors",
        "body": [
            "vector<long long> enum_divisors(long long N, const bool do_sort = true) {",
            "    vector<long long> ret;",
            "",
            "    for (long long i = 1; i * i <= N; i++) {",
            "        if (N % i != 0) continue;",
            "        ret.push_back(i);",
            "        if (i * i != N) ret.push_back(N / i);",
            "    }",
            "",
            "    if (do_sort) sort(ret.begin(), ret.end());",
            "    return ret;",
            "}",
        ],
        "description": "Enumerate divisors of N (O(sqrtN))"
    },

    "Prime": {
        "prefix": "Prime",
        "body": [
            "bool is_prime(long long N) {",
            "    for (long long i = 2; i * i <= N; i++) {",
            "        if (N % i == 0) return false;",
            "    }",
            "    return true;",
            "}",
        ],
        "description": "is N prime or not (O(sqrtN))"
    },

    "Factorization": {
        "prefix": "Factorization",
        "body": [
            "vector<pair<long long, long long> > factorization(long long N) {",
            "    vector<pair<long long, long long> > ret;",
            "    for (long long i = 2; i * i <= N; i++) {",
            "        int cnt = 0;",
            "        while (N % i == 0) {",
            "            cnt++;",
            "            N /= i;",
            "        }",
            "        if (cnt > 0) ret.emplace_back(i, cnt);",
            "    }",
            "    if (N != 1) ret.emplace_back(N, 1);",
            "    return ret;",
            "}",
        ],
        "description": "Factorize N (O(sqrtN)), return (prime, degree)"
    },

    "RLE": {
        "prefix": "RLE",
        "body": [
            "template <typename C>",
            "vector<pair<typename C::value_type, long long> > RunLengthEncoding(C& S) {",
            "  using T = typename C::value_type;",
            "  if (S.empty()) return {};",
            "  ",
            "  vector<pair<T, long long> > ret;",
            "  T prev = S[0];",
            "  int cnt = 1;",
            "  for (int i = 1; i < (int)S.size(); i++) {",
            "    if (S[i] == prev) cnt++;",
            "    else {",
            "      ret.emplace_back(prev, cnt);",
            "      prev = S[i], cnt = 1;",
            "    }",
            "  }",
            "  ret.emplace_back(prev, cnt);",
            "  return ret;",
            "}",
        ],
        "description": "Run Length Encoding of S"
    },

    "DFS": {
        "prefix": "DFS",
        "body": [
            "auto dfs = [&](auto dfs, int now, int par) -> void {",
            "",
            "    for(auto &nxt : G[now]) {",
            "        if(nxt == par) continue;",
            "",
            "        dfs(dfs, nxt, now);",
            "",
            "    }",
            "    return;",
            "};",
        ],
        "description": "Depth First Search (basic form using lamda function)"
    },

    "Dijkstra": {
        "prefix": "Dijkstra",
        "body": [
            "// Dijkstra (basic form)",
            "// 0-indexed, returns the minimum distance of all points on the graph from the starting point",
            "// Edge構造体やdijkstra関数の中身などを適宜弄る",
            "template< typename T = long long >",
            "struct Edge{",
            "    int to;",
            "    T cost;",
            "",
            "    Edge() = default;",
            "    Edge(int to, T cost = 1) : to(to), cost(cost) {}",
            "};",
            "",
            "template< typename T = long long >",
            "using Graph = vector<vector<Edge<T> > >;",
            "",
            "template <typename T>",
            "vector< T > dijkstra(const Graph< T > &G, int start = 0) {",
            "  using P = pair<T, int>; // (cost, idx)",
            "  int N = (int)G.size();",
            "  T na = T(-1);",
            "",
            "  vector< T > dist(N, na);",
            "  priority_queue<P, vector<P>, greater<P> > pq;",
            "  dist[start] = 0;",
            "  pq.push({0, start});",
            "  ",
            "  while (!pq.empty()) {",
            "    auto [nowcost, nowv] = pq.top();",
            "    pq.pop();",
            "",
            "    if (dist[nowv] < nowcost) continue;",
            "",
            "    for (auto &e : G[nowv]) {",
            "      if (dist[e.to] == na || dist[nowv] + e.cost < dist[e.to]) {",
            "            dist[e.to] = dist[nowv] + e.cost;",
            "            pq.push({dist[e.to], e.to});",
            "      }",
            "    }",
            "  }",
            "  ",
            "  return dist;",
            "}",
        ],
        "description": "Dijkstra (basic form), change implementation accordingly"
    },

    "Binary_search": {
        "prefix": "Binary_search",
        "body": [
            "    long long ok = ",
            "    long long ng = ",
            "    while(abs(ok-ng) > 1) {",
            "        long long mid = (ok + ng) / 2;",
            "",
            "        ",
            "",
            "        if( ) ok = mid;",
            "        else ng = mid;",
            "    }",
        ],
        "description": "binary search (basic form)"
    },

    "Unionfind": {
        "prefix": "Unionfind",
        "body": [
            "/// Union-Find",
            "struct unionfind{",
            "    vector<int> par, siz;",
            " ",
            "    unionfind(int n) : par(n, -1), siz(n, 1) {}",
            " ",
            "    // 根を求める",
            "    int root(int x) {",
            "        if (par[x] == -1) return x;",
            "        else return par[x] = root(par[x]);",
            "    }",
            " ",
            "    // xとyの根（グループ）が一致するかどうか",
            "    bool issame(int x, int y){",
            "        return root(x) == root(y);",
            "    }",
            " ",
            "    // xとyのグループの併合",
            "    bool unite(int x, int y){",
            "        x = root(x); y = root(y);",
            " ",
            "        if (x == y) return false;",
            " ",
            "        if (siz[x] < siz[y]) swap(x,y);",
            " ",
            "        par[y] = x;",
            "        siz[x] += siz[y];",
            "        return true;",
            "    }",
            " ",
            "    // xを含むグループのサイズ",
            "    int size(int x){",
            "        return siz[root(x)];",
            "    }",
            "};",
        ],
        "description": "Union-Find (DSU)"
    },

    "BIT": {
        "prefix": "BIT",
        "body": [
            "/// Binary Indexed Tree",
            "template <typename T>",
            "struct BIT {",
            "    int n;          // 配列の要素数(数列の要素数+1)",
            "    vector<T> bit;  // データの格納先",
            "    BIT(int n_) : n(n_ + 1), bit(n, 0) {} // 1-indexed",
            "",
            "    // A_i += x",
            "    void add(int idx, T x) {",
            "        while(idx < n){ // n <- n+1 に予めしてるため等号を含まないことに注意",
            "            bit[idx] += x;",
            "            idx += (idx & -idx);",
            "        }",
            "    }",
            "",
            "    // A_1 ~ A_i の和を計算",
            "    T sum(int idx) {",
            "        T ret(0);",
            "        while(idx > 0){ ",
            "            ret += bit[idx];",
            "            idx -= (idx & -idx);",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    // A_1 + A_2 + ... + A_x >= w となるような最小の x を求める (A_i >= 0)",
            "    int lower_bound(T w) { ",
            "    if (w <= 0) return 0;",
            "    else {",
            "        int x = 0, r = 1;",
            "        while (r < n) r = r << 1;",
            "        for (int len = r; len > 0; len = len >> 1) { ",
            "            if (x + len < n && bit[x + len] < w) { ",
            "                w -= bit[x + len];",
            "                x += len;",
            "                }",
            "            }",
            "            return x + 1;",
            "        }",
            "    }",
            "};",
        ],
        "description": "Binary Indexed Tree"
    },

    "Segtree": {
        "prefix": "Segtree",
        "body": [
            "/// segment tree (from ACL)",
            "// 型S, 二項演算 S op(S a, S b), 単位元 S e() を定義する必要有、モノイドが対象",
            "template <class S, S (*op)(S, S), S (*e)()> struct segtree {",
            "  public:",
            "    segtree() : segtree(0) {}",
            "    explicit segtree(int n) : segtree(std::vector<S>(n, e())) {} // 引数に int n で長さnの数列a(初期値e())を作る",
            "    explicit segtree(const std::vector<S>& v) : _n(int(v.size())) { // 引数に vector<S> v で長さn = v.size() の数列a(初期値はvに従う)を作る",
            "        log = ceil_pow2(_n);",
            "        size = 1 << log;",
            "        d = std::vector<S>(2 * size, e());",
            "        for (int i = 0; i < _n; i++) d[size + i] = v[i];",
            "        for (int i = size - 1; i >= 1; i--) {",
            "            update(i);",
            "        }",
            "    }",
            "",
            "    // a[p]にxを代入（一点更新）",
            "    void set(int p, S x) {",
            "        assert(0 <= p && p < _n);",
            "        p += size;",
            "        d[p] = x;",
            "        for (int i = 1; i <= log; i++) update(p >> i);",
            "    }",
            "",
            "    // a[p]を返す（一点取得）",
            "    S get(int p) const {",
            "        assert(0 <= p && p < _n);",
            "        return d[p + size];",
            "    }",
            "",
            "    // op(a[l], ……, a[r-1]) を計算する（区間に対する演算）",
            "    S prod(int l, int r) const {",
            "        assert(0 <= l && l <= r && r <= _n);",
            "        S sml = e(), smr = e();",
            "        l += size;",
            "        r += size;",
            "",
            "        while (l < r) {",
            "            if (l & 1) sml = op(sml, d[l++]);",
            "            if (r & 1) smr = op(d[--r], smr);",
            "            l >>= 1;",
            "            r >>= 1;",
            "        }",
            "        return op(sml, smr);",
            "    }",
            "",
            "    // op(a[0], ……, a[n-1]) を計算する（全体に対する演算）",
            "    S all_prod() const { return d[1]; }",
            "",
            "    // segment tree 上での二分探索",
            "    template <bool (*f)(S)> int max_right(int l) const {",
            "        return max_right(l, [](S x) { return f(x); });",
            "    }",
            "    template <class F> int max_right(int l, F f) const {",
            "        assert(0 <= l && l <= _n);",
            "        assert(f(e()));",
            "        if (l == _n) return _n;",
            "        l += size;",
            "        S sm = e();",
            "        do {",
            "            while (l % 2 == 0) l >>= 1;",
            "            if (!f(op(sm, d[l]))) {",
            "                while (l < size) {",
            "                    l = (2 * l);",
            "                    if (f(op(sm, d[l]))) {",
            "                        sm = op(sm, d[l]);",
            "                        l++;",
            "                    }",
            "                }",
            "                return l - size;",
            "            }",
            "            sm = op(sm, d[l]);",
            "            l++;",
            "        } while ((l & -l) != l);",
            "        return _n;",
            "    }",
            "",
            "    template <bool (*f)(S)> int min_left(int r) const {",
            "        return min_left(r, [](S x) { return f(x); });",
            "    }",
            "    template <class F> int min_left(int r, F f) const {",
            "        assert(0 <= r && r <= _n);",
            "        assert(f(e()));",
            "        if (r == 0) return 0;",
            "        r += size;",
            "        S sm = e();",
            "        do {",
            "            r--;",
            "            while (r > 1 && (r % 2)) r >>= 1;",
            "            if (!f(op(d[r], sm))) {",
            "                while (r < size) {",
            "                    r = (2 * r + 1);",
            "                    if (f(op(d[r], sm))) {",
            "                        sm = op(d[r], sm);",
            "                        r--;",
            "                    }",
            "                }",
            "                return r + 1 - size;",
            "            }",
            "            sm = op(d[r], sm);",
            "        } while ((r & -r) != r);",
            "        return 0;",
            "    }",
            "",
            "  private:",
            "    int _n, size, log;",
            "    std::vector<S> d;",
            "",
            "    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
            "",
            "    /// return minimum non-negative `x` s.t. `n <= 2**x`",
            "    int ceil_pow2(ll n) {",
            "        int x = 0;",
            "        while ((1ll << x) < n) x++;",
            "        return x;",
            "    }",
            "};",
        ],
        "description": "segment tree (from ACL)"
    },

    "Combination": {
        "prefix": "Combination",
        "body": [
            "/// 二項係数",
            "struct Combination {",
            "    int MAX;",
            "    int MOD;",
            "    vector<long long> fac,finv,inv;",
            "",
            "    Combination(int MAX, int MOD) : MAX(MAX + 1), MOD(MOD) {",
            "        fac.resize(MAX + 1);",
            "        finv.resize(MAX + 1);",
            "        inv.resize(MAX + 1);",
            "        COMinit();",
            "    }",
            "",
            "    void COMinit() {",
            "        fac[0] = fac[1] = 1;",
            "        finv[0] = finv[1] = 1;",
            "        inv[1] = 1;",
            "        for (int i = 2; i < MAX; i++) {",
            "            fac[i] = fac[i - 1] * i % MOD;",
            "            inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;",
            "            finv[i] = finv[i - 1] * inv[i] % MOD;",
            "        }",
            "    }",
            "",
            "    // 二項係数計算",
            "    long long COM(int n, int k) {",
            "        if (n < k) return 0;",
            "        if (n < 0 || k < 0) return 0;",
            "        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;",
            "    }",
            "};",
        ],
        "description": "calculate Combination (nCk)"
    },



    
}