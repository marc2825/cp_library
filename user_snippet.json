{
	"BFS": {
		"prefix": "BFS",
		"body": [
			"// Returns the distance of all points on the graph from the starting point", 
            "vector<int> BFS(const vector<vector<int> > &G, int start) {",
            "    vector<int> dist(G.size(), -1);",
            "    dist[start] = 0;",
            "    queue<int> q;",
            "    q.push(start);",
            "",
            "    while(!q.empty()) {",
            "        int now = q.front();",
            "        q.pop();",
            "",
            "        for(auto &nxt : G[now]) {",
            "            if(dist[nxt] == -1) {",
            "                dist[nxt] = dist[now] + 1;",
            "                q.push(nxt);",
            "            }",
            "        }",
            "    }",
            "",
            "    return dist;",
            "}",
		],
		"description": "Breadth First Search (basic form using lamda function)"
	},

    "Eratosthenes": {
        "prefix": "Eratosthenes",
        "body": [
            "vector<bool> Eratosthenes(int N) {",
            "    vector<bool> isprime(N+1, true);",
            "",
            "    isprime[0] = false;",
            "    isprime[1] = false;",
            "",
            "    for (long long p = 2; p <= N; ++p) {",
            "        if (!isprime[p]) continue;",
            "",
            "        if(p * p > N) break;",
            "",
            "        for (long long q = p * p; q <= N; q += p) {",
            "            isprime[q] = false;",
            "        }",
            "    }",
            "",
            "    return isprime;",
            "}",
        ],
        "description": "Sieve of Eratosthenes (return an isprime table less than N)"
    },

    "Divisors": {
        "prefix": "Divisors",
        "body": [
            "vector<long long> enum_divisors(long long N, const bool do_sort = true) {",
            "    vector<long long> ret;",
            "",
            "    for (long long i = 1; i * i <= N; i++) {",
            "        if (N % i != 0) continue;",
            "        ret.push_back(i);",
            "        if (i * i != N) ret.push_back(N / i);",
            "    }",
            "",
            "    if (do_sort) sort(ret.begin(), ret.end());",
            "    return ret;",
            "}",
        ],
        "description": "Enumerate divisors of N (O(sqrtN))"
    },

    "Prime": {
        "prefix": "Prime",
        "body": [
            "bool is_prime(long long N) {",
            "    for (long long i = 2; i * i <= N; i++) {",
            "        if (N % i == 0) return false;",
            "    }",
            "    return true;",
            "}",
        ],
        "description": "is N prime or not (O(sqrtN))"
    },

    "Factorization": {
        "prefix": "Factorization",
        "body": [
            "vector<pair<long long, long long> > factorization(long long N) {",
            "    vector<pair<long long, long long> > ret;",
            "    for (long long i = 2; i * i <= N; i++) {",
            "        int cnt = 0;",
            "        while (N % i == 0) {",
            "            cnt++;",
            "            N /= i;",
            "        }",
            "        if (cnt > 0) ret.emplace_back(i, cnt);",
            "    }",
            "    if (N != 1) ret.emplace_back(N, 1);",
            "    return ret;",
            "}",
        ],
        "description": "Factorize N (O(sqrtN)), return (prime, degree)"
    },

    "RLE": {
        "prefix": "RLE",
        "body": [
            "template <typename C>",
            "vector<pair<typename C::value_type, long long> > RunLengthEncoding(C& S) {",
            "  using T = typename C::value_type;",
            "  if (S.empty()) return {};",
            "  ",
            "  vector<pair<T, long long> > ret;",
            "  T prev = S[0];",
            "  int cnt = 1;",
            "  for (int i = 1; i < (int)S.size(); i++) {",
            "    if (S[i] == prev) cnt++;",
            "    else {",
            "      ret.emplace_back(prev, cnt);",
            "      prev = S[i], cnt = 1;",
            "    }",
            "  }",
            "  ret.emplace_back(prev, cnt);",
            "  return ret;",
            "}",
        ],
        "description": "Run Length Encoding of S"
    },

    "DFS": {
        "prefix": "DFS",
        "body": [
            "auto dfs = [&](auto dfs, int now, int par) -> void {",
            "",
            "    for(auto &nxt : G[now]) {",
            "        if(nxt == par) continue;",
            "",
            "        dfs(dfs, nxt, now);",
            "",
            "    }",
            "    return;",
            "};",
        ],
        "description": "Depth First Search (basic form using lamda function)"
    },

    "Dijkstra": {
        "prefix": "Dijkstra",
        "body": [
            "// Dijkstra (basic form)",
            "// 0-indexed, returns the minimum distance of all points on the graph from the starting point",
            "// Edge構造体やdijkstra関数の中身などを適宜弄る",
            "template< typename T = long long >",
            "struct Edge{",
            "    int to;",
            "    T cost;",
            "",
            "    Edge() = default;",
            "    Edge(int to, T cost = 1) : to(to), cost(cost) {}",
            "};",
            "",
            "template< typename T = long long >",
            "using Graph = vector<vector<Edge<T> > >;",
            "",
            "template <typename T>",
            "vector< T > dijkstra(const Graph< T > &G, int start = 0) {",
            "  using P = pair<T, int>; // (cost, idx)",
            "  int N = (int)G.size();",
            "  T na = T(-1);",
            "",
            "  vector< T > dist(N, na);",
            "  priority_queue<P, vector<P>, greater<P> > pq;",
            "  dist[start] = 0;",
            "  pq.push({0, start});",
            "  ",
            "  while (!pq.empty()) {",
            "    auto [nowcost, nowv] = pq.top();",
            "    pq.pop();",
            "",
            "    if (dist[nowv] < nowcost) continue;",
            "",
            "    for (auto &e : G[nowv]) {",
            "      if (dist[e.to] == na || dist[nowv] + e.cost < dist[e.to]) {",
            "            dist[e.to] = dist[nowv] + e.cost;",
            "            pq.push({dist[e.to], e.to});",
            "      }",
            "    }",
            "  }",
            "  ",
            "  return dist;",
            "}",
        ],
        "description": "Dijkstra (basic form), change implementation accordingly"
    },

    "Binary_search": {
        "prefix": "Binary_search",
        "body": [
            "    long long ok = ",
            "    long long ng = ",
            "    while(abs(ok-ng) > 1) {",
            "        long long mid = (ok + ng) / 2;",
            "",
            "        ",
            "",
            "        if( ) ok = mid;",
            "        else ng = mid;",
            "    }",
        ],
        "description": "binary search (basic form)"
    },

    "Unionfind": {
        "prefix": "Unionfind",
        "body": [
            "/// Union-Find",
            "struct unionfind{",
            "    vector<int> par, siz;",
            " ",
            "    unionfind(int n) : par(n, -1), siz(n, 1) {}",
            " ",
            "    // 根を求める",
            "    int root(int x) {",
            "        if (par[x] == -1) return x;",
            "        else return par[x] = root(par[x]);",
            "    }",
            " ",
            "    // xとyの根（グループ）が一致するかどうか",
            "    bool issame(int x, int y){",
            "        return root(x) == root(y);",
            "    }",
            " ",
            "    // xとyのグループの併合",
            "    bool unite(int x, int y){",
            "        x = root(x); y = root(y);",
            " ",
            "        if (x == y) return false;",
            " ",
            "        if (siz[x] < siz[y]) swap(x,y);",
            " ",
            "        par[y] = x;",
            "        siz[x] += siz[y];",
            "        return true;",
            "    }",
            " ",
            "    // xを含むグループのサイズ",
            "    int size(int x){",
            "        return siz[root(x)];",
            "    }",
            "};",
        ],
        "description": "Union-Find (DSU)"
    },

    "BIT": {
        "prefix": "BIT",
        "body": [
            "/// Binary Indexed Tree",
            "// 0-indexed / 半開区間 で外からはアクセスできるようにしている（内部では1-indexedで取り扱っている）",
            "template <class T>",
            "struct BIT {",
            "    int n;          // 配列の要素数（1-indexedのため、数列の要素数+1する）",
            "    vector<T> bit;  // BITデータ(1-indexed)の格納先",
            "    vector<T> val;  // 実データ(1-indexed)の格納先",
            "    BIT(int n_) : n(n_ + 1), bit(n, 0), val(n, 0) {} // 1-indexed",
            "",
            "    // A_i += x (0-indexed)",
            "    void add(int idx, T x) {",
            "        idx++;",
            "        val[idx] += x;",
            "        while(idx < n){",
            "            bit[idx] += x;",
            "            idx += (idx & -idx);",
            "        }",
            "    }",
            "",
            "    // get A_i (0-indexed)",
            "    T get(int idx) {",
            "        return val[idx+1];",
            "    }",
            "",
            "    // A_i = x (0-indexed)",
            "    void set(int idx, T x) {",
            "        add(idx, x-get(idx));",
            "    }",
            "",
            "    // A_0 ~ A_(idx-1) の和を計算 (idx含まない) (0-indexed / 半開区間)",
            "    T sum(int idx) {",
            "        T ret = 0;",
            "        while(idx > 0){ ",
            "            ret += bit[idx];",
            "            idx -= (idx & -idx);",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    // A[l,r)の和を計算 (0-indexed / 半開区間)",
            "    T sum(int l, int r) {",
            "        return sum(r) - sum(l);",
            "    }",
            "",
            "    // A_0 + A_1 + ... + A_x >= w となるような最小の x を求める (A_i >= 0) (0-indexedで返している)",
            "    int lower_bound(T w) { ",
            "    if (w <= 0) return 0;",
            "    else {",
            "        int x = 0, r = 1; // xでギリギリNG",
            "        while (r < n) r = r << 1;",
            "        for (int len = r; len > 0; len = len >> 1) { ",
            "            if (x + len < n && bit[x + len] < w) { ",
            "                w -= bit[x + len];",
            "                x += len;",
            "                }",
            "            }",
            "",
            "            return x; // 0-indexedで返す",
            "        }",
            "    }",
            "};",
        ],
        "description": "Binary Indexed Tree"
    },


    "Segtree": {
        "prefix": "Segtree",
        "body": [
            "/// segment tree (from ACL)",
            "// 型S, 二項演算 S op(S a, S b), 単位元 S e() を定義する必要有、モノイドが対象",
            "template <class S, S (*op)(S, S), S (*e)()> struct segtree {",
            "  public:",
            "    segtree() : segtree(0) {}",
            "    explicit segtree(int n) : segtree(std::vector<S>(n, e())) {} // 引数に int n で長さnの数列a(初期値e())を作る",
            "    explicit segtree(const std::vector<S>& v) : _n(int(v.size())) { // 引数に vector<S> v で長さn = v.size() の数列a(初期値はvに従う)を作る",
            "        log = ceil_pow2(_n);",
            "        size = 1 << log;",
            "        d = std::vector<S>(2 * size, e());",
            "        for (int i = 0; i < _n; i++) d[size + i] = v[i];",
            "        for (int i = size - 1; i >= 1; i--) {",
            "            update(i);",
            "        }",
            "    }",
            "",
            "    // a[p]にxを代入（一点更新）",
            "    void set(int p, S x) {",
            "        assert(0 <= p && p < _n);",
            "        p += size;",
            "        d[p] = x;",
            "        for (int i = 1; i <= log; i++) update(p >> i);",
            "    }",
            "",
            "    // a[p]を返す（一点取得）",
            "    S get(int p) const {",
            "        assert(0 <= p && p < _n);",
            "        return d[p + size];",
            "    }",
            "",
            "    // op(a[l], ……, a[r-1]) を計算する（区間に対する演算）",
            "    S prod(int l, int r) const {",
            "        assert(0 <= l && l <= r && r <= _n);",
            "        S sml = e(), smr = e();",
            "        l += size;",
            "        r += size;",
            "",
            "        while (l < r) {",
            "            if (l & 1) sml = op(sml, d[l++]);",
            "            if (r & 1) smr = op(d[--r], smr);",
            "            l >>= 1;",
            "            r >>= 1;",
            "        }",
            "        return op(sml, smr);",
            "    }",
            "",
            "    // op(a[0], ……, a[n-1]) を計算する（全体に対する演算）",
            "    S all_prod() const { return d[1]; }",
            "",
            "    // segment tree 上での二分探索",
            "    template <bool (*f)(S)> int max_right(int l) const {",
            "        return max_right(l, [](S x) { return f(x); });",
            "    }",
            "    template <class F> int max_right(int l, F f) const {",
            "        assert(0 <= l && l <= _n);",
            "        assert(f(e()));",
            "        if (l == _n) return _n;",
            "        l += size;",
            "        S sm = e();",
            "        do {",
            "            while (l % 2 == 0) l >>= 1;",
            "            if (!f(op(sm, d[l]))) {",
            "                while (l < size) {",
            "                    l = (2 * l);",
            "                    if (f(op(sm, d[l]))) {",
            "                        sm = op(sm, d[l]);",
            "                        l++;",
            "                    }",
            "                }",
            "                return l - size;",
            "            }",
            "            sm = op(sm, d[l]);",
            "            l++;",
            "        } while ((l & -l) != l);",
            "        return _n;",
            "    }",
            "",
            "    template <bool (*f)(S)> int min_left(int r) const {",
            "        return min_left(r, [](S x) { return f(x); });",
            "    }",
            "    template <class F> int min_left(int r, F f) const {",
            "        assert(0 <= r && r <= _n);",
            "        assert(f(e()));",
            "        if (r == 0) return 0;",
            "        r += size;",
            "        S sm = e();",
            "        do {",
            "            r--;",
            "            while (r > 1 && (r % 2)) r >>= 1;",
            "            if (!f(op(d[r], sm))) {",
            "                while (r < size) {",
            "                    r = (2 * r + 1);",
            "                    if (f(op(d[r], sm))) {",
            "                        sm = op(d[r], sm);",
            "                        r--;",
            "                    }",
            "                }",
            "                return r + 1 - size;",
            "            }",
            "            sm = op(d[r], sm);",
            "        } while ((r & -r) != r);",
            "        return 0;",
            "    }",
            "",
            "  private:",
            "    int _n, size, log;",
            "    std::vector<S> d;",
            "",
            "    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
            "",
            "    /// return minimum non-negative `x` s.t. `n <= 2**x`",
            "    int ceil_pow2(ll n) {",
            "        int x = 0;",
            "        while ((1ll << x) < n) x++;",
            "        return x;",
            "    }",
            "};",
        ],
        "description": "segment tree (from ACL)"
    },

    "Combination": {
        "prefix": "Combination",
        "body": [
            "/// 二項係数",
            "struct Combination {",
            "    int MAX;",
            "    int MOD;",
            "    vector<long long> fac,finv,inv;",
            "",
            "    Combination(int MAX, int MOD) : MAX(MAX + 1), MOD(MOD) {",
            "        fac.resize(MAX + 1);",
            "        finv.resize(MAX + 1);",
            "        inv.resize(MAX + 1);",
            "        COMinit();",
            "    }",
            "",
            "    void COMinit() {",
            "        fac[0] = fac[1] = 1;",
            "        finv[0] = finv[1] = 1;",
            "        inv[1] = 1;",
            "        for (int i = 2; i < MAX; i++) {",
            "            fac[i] = fac[i - 1] * i % MOD;",
            "            inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;",
            "            finv[i] = finv[i - 1] * inv[i] % MOD;",
            "        }",
            "    }",
            "",
            "    // 二項係数計算",
            "    long long COM(int n, int k) {",
            "        if (n < k) return 0;",
            "        if (n < 0 || k < 0) return 0;",
            "        return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;",
            "    }",
            "};",
        ],
        "description": "calculate Combination (nCk)"
    },

    "Grid_BFS": {
        "prefix": "Grid_BFS",
        "body": [
            "// Returns the distance of all points on the graph from the starting point",
            "// 二次元配列での (i,j) が (y,x) と対応 (二次元座標と同じ)",
            "// 上下左右4方向への探索、通行不可文字はngで指定（適宜書き換えても良い）",
            "vector<vector<int> > Grid_BFS(const vector<string> &G, int sy, int sx, char ng = '#') {",
            "    int H = G.size();",
            "    int W = G[0].size();",
            "    vector<vector<int> > dist(H, vector<int>(W, -1));",
            "    dist[sy][sx] = 0;",
            "    queue<pair<int, int> > q;",
            "    q.push({sy,sx});",
            "",
            "    while(!q.empty()) {",
            "        auto [y,x] = q.front();",
            "        q.pop();",
            "",
            "        for(int k = 0; k < 4; k++) {",
            "            int ny = y + dy1[k];",
            "            int nx = x + dx1[k];",
            "",
            "            if(include(ny,nx,H,W) && dist[ny][nx] == -1 && G[ny][nx] != ng) {",
            "                dist[ny][nx] = dist[y][x] + 1;",
            "                q.push({ny,nx});",
            "            }",
            "        }",
            "    }",
            "",
            "    return dist;",
            "}",
        ],
        "description": "BFS on Grid (basic form)"
    },

    "2DCumulativeSum": {
        "prefix": "2DCumulativeSum",
        "body": [
            "/// 二次元累積和",
            "// 0-indexed / 半開区間 で外からはアクセス、内部では1-indexed的に累積和を処理",
            "template< class T >",
            "struct CumulativeSum2D {",
            "    vector< vector< T > > data;",
            "",
            "    CumulativeSum2D(int H, int W) : data(H + 1, vector< T >(W + 1, 0)) {}",
            "",
            "    // 0-indexedでアクセス",
            "    void add(int x, int y, T z) {",
            "        x++, y++;",
            "        if(x >= (int)data.size() || y >= (int)data[0].size()) return;",
            "        data[x][y] += z;",
            "    }",
            "",
            "    void build() {",
            "        for(int i = 1; i < (int)data.size(); i++) {",
            "            for(int j = 1; j < (int)data[i].size(); j++) {",
            "                data[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1];",
            "            }",
            "        }",
            "    }",
            "",
            "    // 端を (sx, sy) ~ (gx, gy) とするような矩形領域の和を求める",
            "    // 0-indexedでアクセス、半開区間扱いなので、gx/gyの行/列の値は含まれないことに注意",
            "    T query(int sx, int sy, int gx, int gy) const {",
            "        return (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);",
            "    }",
            "};",
        ],
        "description": "2D Cumulative Sum"
    },


    "Graph_simple": {
        "prefix": "Graph_simple",
        "body": [
            "/// 辺 (始点 from、終点 to、コスト cost、インデックス idx) を管理する構造体 Edge",
            "// cost の型Tを渡す (初期設定は long long)",
            "template< typename T = long long >",
            "struct Edge {",
            "    int from, to;",
            "    T cost;",
            "    int idx;",
            "",
            "    Edge() = default;",
            "",
            "    Edge(int from_, int to_, T cost_ = 1, int idx_ = -1) : from(from_), to(to_), cost(cost_), idx(idx_) {}",
            "};",
            "",
            "template< typename T = long long >",
            "using graph = vector< vector< Edge< T > > >;",
        ],
        "description": "Graph & Edge struct (simple version)"
    },

    "Bit_BruteForce": {
        "prefix": "Bit_BruteForce",
        "body": [
            "    auto bit_bruteforce = [&](int N) -> void{",
            "",
            "        for(int i = 0; i < (1 << N); i++) {",
            "            ",
            "            for(int j = 0; j < N; j++) {",
            "                if((i >> j) & 1) {",
            "",
            "",
            "                }",
            "            }",
            "        }",
            "    };",
        ],
        "description": "bit brute force ( O(2^N) )"
    },

    "TSP": {
        "prefix": "TSP",
        "body": [
            "        auto TSP = [&](int N) -> void{",
            "            for(int i = 0; i < (1 << N); i++) {",
            "                for(int j = 0; j < N; j++) {",
            "                    if(dp[i][j] == INFL) continue; // check",
            "",
            "                    if((i >> j) & 1) {",
            "                        for(int k = 0; k < N; k++) {",
            "                            if(cost[j][k] == INFL) continue; // check",
            "",
            "                            if(((i >> k) & 1) == 0) {",
            "                                chmin(dp[i | (1 << k)][k], dp[i][j] + cost[j][k]);",
            "                            }",
            "                        }",
            "                    }",
            "                }",
            "            }",
            "        };",
        ],
        "description": "DP used for Travel Salesman Problem ( Permutation to power2 O(N!) -> O(N^2*2^N) )"
    },

    "Permutation_BruteForce": {
        "prefix": "Permutation_BruteForce",
        "body": [
            "    auto perm_bruteforce = [&](int N) -> {",
            "        vector<int> perm(N);",
            "        for(int i = 0; i < N; i++) perm[i] = i;",
            "",
            "        do {",
            "",
            "",
            "        } while (next_permutation(perm.begin(), perm.end()));",
            "",
            "    };",
        ],
        "description": "permutation brute force ( O(N!) )"
    },

    "Matrix": {
        "prefix": "Matrix",
        "body": [
            "/// 行列A・B同士の積 (modが必要ならば指定する、不要ならそのまま)",
            "template<typename T>",
            "vector<vector<T> > matrix_prod(const vector<vector<T> > &A, const vector<vector<T> > &B, const int mod = -1){",
            "    // Aは i * k , Bは k * j の行列 -> 積で i * j の行列を返す",
            "    assert(A[0].size() == B.size());",
            "    int r = A.size();",
            "    int c = B[0].size();",
            "",
            "    vector<vector<T> > ret(r, vector<T>(c,0));",
            "    for(int i = 0; i < r; i++){",
            "        for(int j = 0; j < c; j++){",
            "            for(int k = 0; k < (int)B.size(); k++){",
            "                ret[i][j] += A[i][k] * B[k][j];",
            "                if(mod > 0) ret[i][j] %= mod;",
            "            }",
            "        }",
            "    }",
            "    return ret;",
            "}",
            "",
            "/// 行列累乗 (A^k) (modが必要ならば指定する、不要ならそのまま)",
            "template <typename T> ",
            "vector<vector<T> > matrirx_pow(vector<vector<T> > A, long long k, const int mod = -1) {",
            "    if(A.empty()) return A;",
            "    vector<vector<T> > ret(A.size(), vector<T>(A[0].size()));",
            "    for(int i = 0; i < (int)A.size(); i++) ret[i][i] = 1;",
            "",
            "    while(k > 0) {",
            "        if(k & 1) ret = matrix_prod(ret, A, mod);",
            "        A = matrix_prod(A, A, mod);",
            "        k >>= 1;",
            "    }",
            "    return ret;",
            "}",
            "",
            "/// 反時計周りに 90 度回転",
            "template <typename T> ",
            "void matrix_rotate_anticlock(vector<vector<T> > &A) {",
            "    if(A.empty() || A[0].empty()) return;",
            "    int R = A.size();",
            "    int C = A[0].size();",
            "    vector<vector<T> > ret(C, vector<T>(R));",
            "    for(int i = 0; i < R; i++) ",
            "        for(int j = 0; j < C; j++) ret[C - 1 - j][i] = A[i][j];",
            "    swap(A, ret);",
            "}",
            "",
            "",
            "// 行列を時計回りに90度回転",
            "template<typename T>",
            "void matrix_rotate_clock(vector<vector<T> > &A) {",
            "    if(A.empty() || A[0].empty()) return;",
            "    int R = A.size();",
            "    int C = A[0].size(); ",
            "    vector<vector<T> > ret(C, vector<T>(R));",
            "    for(int i = 0; i < R; i++)",
            "        for(int j = 0; j < C; j++) ret[j][R-1-i] = A[i][j];",
            "    swap(A, ret);",
            "}",
        ],
        "description": "Matrix basic operation (prod * , pow ^, rotate)"
    },






    
}