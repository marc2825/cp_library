{
	"BFS": {
		"prefix": "BFS",
		"body": [
			"// Returns the distance of all points on the graph from the starting point", 
            "vector<int> BFS(const vector<vector<int> > &G, int start) {",
            "    vector<int> dist(G.size(), -1);",
            "    dist[start] = 0;",
            "    queue<int> q;",
            "    q.push(start);",
            "",
            "    while(!q.empty()) {",
            "        int now = q.front();",
            "        q.pop();",
            "",
            "        for(auto &nxt : G[now]) {",
            "            if(dist[nxt] == -1) {",
            "                dist[nxt] = dist[now] + 1;",
            "                q.push(nxt);",
            "            }",
            "        }",
            "    }",
            "",
            "    return dist;",
            "}",
		],
		"description": "Breadth First Search (basic form using lamda function)"
	},

    "Eratosthenes": {
        "prefix": "Eratosthenes",
        "body": [
            "vector<bool> Eratosthenes(int N) {",
            "    vector<bool> isprime(N+1, true);",
            "",
            "    isprime[0] = false;",
            "    isprime[1] = false;",
            "",
            "    for (long long p = 2; p <= N; ++p) {",
            "        if (!isprime[p]) continue;",
            "",
            "        if(p * p > N) break;",
            "",
            "        for (long long q = p * p; q <= N; q += p) {",
            "            isprime[q] = false;",
            "        }",
            "    }",
            "",
            "    return isprime;",
            "}",
        ],
        "description": "Sieve of Eratosthenes (return an isprime table less than N)"
    },

    "Divisors": {
        "prefix": "Divisors",
        "body": [
            "vector<long long> enum_divisors(long long N, const bool do_sort = true) {",
            "    vector<long long> ret;",
            "",
            "    for (long long i = 1; i * i <= N; i++) {",
            "        if (N % i != 0) continue;",
            "        ret.push_back(i);",
            "        if (i * i != N) ret.push_back(N / i);",
            "    }",
            "",
            "    if (do_sort) sort(ret.begin(), ret.end());",
            "    return ret;",
            "}",
        ],
        "description": "Enumerate divisors of N (O(sqrtN))"
    },

    "Prime": {
        "prefix": "Prime",
        "body": [
            "bool is_prime(long long N) {",
            "    for (long long i = 2; i * i <= N; i++) {",
            "        if (N % i == 0) return false;",
            "    }",
            "    return true;",
            "}",
        ],
        "description": "is N prime or not (O(sqrtN))"
    },

    "Factorization": {
        "prefix": "Factorization",
        "body": [
            "vector<pair<long long, int> > factorization(long long N) {",
            "    vector<pair<long long, int> > ret;",
            "    for (long long i = 2; i * i <= N; i++) {",
            "        int cnt = 0;",
            "        while (N % i == 0) {",
            "            cnt++;",
            "            N /= i;",
            "        }",
            "        if (cnt > 0) ret.emplace_back(i, cnt);",
            "    }",
            "    if (N != 1) ret.emplace_back(N, 1);",
            "    return ret;",
            "}",
        ],
        "description": "Factorize N (O(sqrtN)), return (prime, degree)"
    },

    "RLE": {
        "prefix": "RLE",
        "body": [
            "template <typename C>",
            "vector<pair<typename C::value_type, int> > RunLengthEncoding(C& S) {",
            "  using T = typename C::value_type;",
            "  if (S.empty()) return {};",
            "  ",
            "  vector<pair<T, int> > ret;",
            "  T prev = S[0];",
            "  int cnt = 1;",
            "  for (int i = 1; i < (int)S.size(); i++) {",
            "    if (S[i] == prev) cnt++;",
            "    else {",
            "      ret.emplace_back(prev, cnt);",
            "      prev = S[i], cnt = 1;",
            "    }",
            "  }",
            "  ret.emplace_back(prev, cnt);",
            "  return ret;",
            "}",
        ],
        "description": "Run Length Encoding of S"
    },

    "DFS": {
        "prefix": "DFS",
        "body": [
            "auto dfs = [&](auto dfs, int now, int par) -> void {",
            "",
            "    for(auto &nxt : G[now]) {",
            "",
            "        dfs(dfs, nxt, now);",
            "",
            "    }",
            "",
            "};",
        ],
        "description": "Depth First Search (basic form using lamda function)"
    },

    "dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "// Dijkstra (basic form)",
            "// 0-indexed, returns the minimum distance of all points on the graph from the starting point",
            "// Edge構造体やdijkstra関数の中身などを適宜弄る",
            "template< typename T = long long >",
            "struct Edge{",
            "    int to;",
            "    T cost;",
            "",
            "    Edge() = default;",
            "    Edge(int to, T cost = 1) : to(to), cost(cost) {}",
            "};",
            "",
            "template< typename T = long long >",
            "using Graph = vector<vector<Edge<T> > >;",
            "",
            "template <typename T>",
            "vector< T > dijkstra(const Graph< T > &G, int start = 0) {",
            "  using P = pair<T, int>; // (cost, idx)",
            "  int N = (int)G.size();",
            "  T na = T(-1);",
            "",
            "  vector< T > dist(N, na);",
            "  priority_queue<P, vector<P>, greater<P> > pq;",
            "  dist[start] = 0;",
            "  pq.push({0, start});",
            "  ",
            "  while (!pq.empty()) {",
            "    auto [nowcost, nowv] = pq.top();",
            "    pq.pop();",
            "",
            "    if (dist[nowv] < nowcost) continue;",
            "",
            "    for (auto &e : G[nowv]) {",
            "      if (dist[e.to] == na || dist[nowv] + e.cost < dist[e.to]) {",
            "            dist[e.to] = dist[nowv] + e.cost;",
            "            pq.push({dist[e.to], e.to});",
            "      }",
            "    }",
            "  }",
            "  ",
            "  return dist;",
            "}",
        ],
        "description": "Dijkstra (basic form), change implementation accordingly"
    },




    
}